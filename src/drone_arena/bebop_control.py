import math
import numpy as np
import rospy
from bebop_msgs.msg import \
    Ardrone3PilotingStateFlyingStateChanged as FlyingStateChanged
from bebop_msgs.msg import \
    CommonCommonStateBatteryStateChanged as BatteryStateChanged
from geometry_msgs.msg import Twist, Vector3
from std_msgs.msg import Empty
from typing import Tuple  # noqa
from sensor_msgs.msg import BatteryState as BatteryStateMsg

from .control import BatteryState, Controller, State

F = 2.83


class BebopController(Controller):

    # ---- concrete implementation

    @staticmethod
    def cmd_from(acc, speed_z, omega):
        # type: (np.ndarray, float, float) -> Twist
        msg = Twist()
        msg.linear = Vector3(acc[0] / F, acc[1] / F, speed_z)
        msg.angular = Vector3(0, 0, omega / 1.75)
        return msg

    @staticmethod
    def from_cmd(pitch, roll, z, omega):
        # type: (float, float, float, float) -> Tuple[Tuple[float, float, float], float, float]
        return ((F * pitch, F * roll, 0), z, omega * 1.75)

    # TODO: parametrize
    def give_feedback(self):
        # type: () -> None
        A = rospy.get_param('~feedback/amplitude', 1)
        n = rospy.get_param('~feedback/movements', 1)
        t_up = rospy.get_param('~feedback/up', 0.15)
        t_down = rospy.get_param('~feedback/down', 0.5)
        rospy.loginfo("Start gesture with A %s, n %s, dt (%s, %s)", A, n, t_up, t_down)
        for _ in range(n):
            for dz, dt in zip([A, -A], [t_up, t_down]):
                self.des_cmd_pub.publish(Twist(linear=Vector3(0, 0, dz / dt)))
                rospy.sleep(dt)
        self.des_cmd_pub.publish(Twist(linear=Vector3(0, 0, 0)))

    def stop(self, msg=None):
        # type: (Empty) -> None
        self.pub_reset.publish()

    def hover(self):
        # type: () -> None
        if self.state == State.flying:
            self.des_cmd_pub.publish(Twist())

    def takeoff(self):
        # type: () -> None
        self.pub_takeoff.publish(Empty())
        # TODO: add callback (currently not working in bebop driver + melodic)

    def land(self):
        # type: () -> None
        self.pub_land.publish(Empty())

    def __init__(self):
        # type: () -> None
        super(BebopController, self).__init__()
        self.battery_pub = rospy.Publisher('battery', BatteryStateMsg, queue_size=1, latch=True)
        self.battery_msg = BatteryStateMsg()
        self.battery_msg.header.frame_id = 'battery'
        self.battery_msg.voltage = 12.6
        self.battery_msg.current = self.battery_msg.charge = self.battery_msg.capacity = float('nan')
        self.battery_msg.design_capacity = float('nan')
        self.power_supply_status = BatteryStateMsg.POWER_SUPPLY_STATUS_DISCHARGING
        self.battery_msg.present = True

        rospy.set_param('bebop_driver/states/enable_pilotingstate_flyingstatechanged', True)
        rospy.Subscriber('states/ardrone3/PilotingState/FlyingStateChanged', FlyingStateChanged,
                         self.state_has_changed)
        rospy.set_param('bebop_driver/states/enable_commonstate_batterystatechanged', True)
        rospy.Subscriber('states/common/CommonState/BatteryStateChanged', BatteryStateChanged,
                         self.has_received_battery)
        self.battery_state = BatteryState.ok
        self.pub_takeoff = rospy.Publisher('takeoff', Empty, queue_size=1)
        self.pub_land = rospy.Publisher('land', Empty, queue_size=1)
        self.pub_reset = rospy.Publisher('reset', Empty, queue_size=1)

    def has_received_battery(self, msg):
        # type: (BatteryStateChanged) -> None
        if msg.percent < 5 and self.battery_state == BatteryState.ok:
            self.battery_state = BatteryState.critical
        if msg.percent < 2 and self.battery_state == BatteryState.critical:
            self.battery_state = BatteryState.empty
        self.battery_percent = msg.percent
        self.battery_msg.percentage = msg.percent / 100.0
        self.battery_pub.publish(self.battery_msg)

    def state_has_changed(self, msg):
        # type: (FlyingStateChanged) -> None
        # Ardrone3PilotingStateFlyingStateChanged.msg
        # see https://bebop-autonomy.readthedocs.io/en/latest/autogenerated/
        # ardrone3_states_param_topic.html
        # uint8 state_landed=0  # Landed state
        # uint8 state_takingoff=1  # Taking off state
        # uint8 state_hovering=2  # Hovering / Circling (for fixed wings) state
        # uint8 state_flying=3  # Flying state
        # uint8 state_landing=4  # Landing state
        # uint8 state_emergency=5  # Emergency state
        # uint8 state_usertakeoff=6  # User take off state. Waiting for user action to take off.
        # uint8 state_motor_ramping=7  # Motor ramping state (for fixed wings).
        # uint8 state_emergency_landing=8  # Emergency landing state. Drone autopilot
        # has detected defective sensor(s). Only Yaw argument in PCMD is taken into account.
        # All others flying commands are ignored.
        # uint8 state
        # rospy.loginfo("state_has_changed %s", msg)
        if msg.state == FlyingStateChanged.state_takingoff:
            self.state = State.taking_off
        elif msg.state == FlyingStateChanged.state_hovering:
            self.state = State.hovering
        elif msg.state == FlyingStateChanged.state_flying:
            self.state = State.flying
        elif msg.state in [FlyingStateChanged.state_landing,
                           FlyingStateChanged.state_emergency_landing]:
            self.state = State.landing
        elif msg.state in [FlyingStateChanged.state_landed, FlyingStateChanged.state_emergency]:
            self.state = State.landed
        else:
            rospy.logwarn("Unexpected state msg %s for bebop", msg)
        # rospy.loginfo("bebop state -> %s", self.state)
